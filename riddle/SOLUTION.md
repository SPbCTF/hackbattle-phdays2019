На видео: [1:48:28](https://vk.com/video-114366489_456239197?t=1h48m28s)

Можно обратить внимание, что при проверке вводимого пароля никаких запросов на сервер не отправляется - значит, проверка полностью выполняется на клиентской стороне. Смотрим код страницы и видим, что он импортирует функцию `check_password` из скомпилированного `riddle_bg.wasm`. Значит, чтобы посмотреть проверку пароля, нужно декомпилировать Web Assembly.

В это может помочь [WABT (The WebAssembly Binary Toolkit)](https://github.com/WebAssembly/wabt).

Можно собрать декомпилятор из репозитория и получить псевдокод на C (как сделали участники на PHD), или воспользоваться онлайн-демо (но там придется смотреть инструкции Web-assembly).

Рассмотрим второй путь решения. Заливаем `riddle_bg.wasm` на [wasm2wat demo](https://webassembly.github.io/wabt/demo/wasm2wat/) и получаем дизассемблированный код. Ищем в нем функцию `check_password`: 

```
(func $check_password (export "check_password") (type $t2) (param $p0 i32) (param $p1 i32) (result i32)
``` 

Принимает два параметра: `$p0` - строка и `$p1` - ее длина. Затем в теле функции следует ряд проверок. Первая:

```
(br_if $B0
          (i32.ne
            (local.get $p1)
            (i32.const 30)))
```

Здесь происходит сравнение длины входной строки со значением `30`, и если длина отличается - блок выполнения завершается. Далее следует ряд однотипных сравнений:

```
(br_if $B0
          (i32.ne
            (i32.load8_u offset=9
              (local.get $p0))
            (i32.const 114)))
```

Здесь сравнивается значение из входной строки `$p0` по смещению `9` со значением `114` (десятичный ascii-код символа `r`). 

Функция `check_password` посимвольно проверяет введенный пароль. Соберем все сравниваемые значения в правильном порядке и получим флаг. 

Флаг: `CTF{th3_an5w3r_15_n0t_42_but_31337}`
